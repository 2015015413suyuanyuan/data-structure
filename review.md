# 数据结构复习
## 第一章 绪论

数据结构的研究内容:   
>   **逻辑结构**：研究对象的特性及其相互之间的关系  
>   **存储结构**：有效地组织计算机存储  
>   **算法**:有效地实现对象之间的“运算”关系  

《数据结构》是一门研究非数值计算的程序设计问题中计算机的**操作对象**以及它们之间的**关系**和**操作**的一门学科。


数据结构： **线性表（一般线性表、操作受限线性表、数据受限线性表、线性表的扩展）  树（二叉树）  图**

算法： **查找  排序**

四类基本数据结构：**集合结构 线性结构  树形结构  图状结构**

关系、关联的表示用**（序偶）**表示。 三种基本的关系： *1:1   1:n  n:m*

+ 物理结构（存储结构）  
    >   数据结构在计算机中的表示（映像）称为数据的物理结构  
* 顺序映像  
    >   顺序映像的特点是借助元素在储蓄器中的相对位置来表示数据元素之间的逻辑关系。  
* 非顺序映像  
    >   非顺序映像的特点是借助指示元素存储地址的指针表示数据元素之间的逻辑关系。  


**数据类型**： 是一组性质相同的**值的集合**以及定义于这个值集合上的一组操作的总称。

**数据类型的作用**：约束变量的**内存空间**   约束变量或常量的**取值范围、操作**

* 抽象数据类型（abstract data type ADT）  
    是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。  
含义： 一种数据类型，其数据对象和对象操作的规格说明独立于对象的存储表示和对象上操作的实现。

**抽象数据类型的定义**  
* 和数据结构的形式定义相对应，抽象数据类型可以用三元组来刻画:(D,S,P)。其中D是数据对象，S是D上的关系集，P是对D的基本操作。  
```
     ADT  抽象数据类型名{
               数据对象：<数据对象的定义>
               数据关系：<数据关系的定义>
               基本操作：<基本操作的定义>
     } ADT  抽象数据类型名
              其中，数据对象和数据关系的定义用伪码描述，基本操作的定义格式为：
     基本操作名(参数表)
              初始条件：<初始条件描述>
              操作结果：<操作结果描述>
```

二元组定义的例子：  
```
ADT Compare{
     数据对象：D={e1,e2| e1,e2为可比较的同类型的元素}
     数据关系：R={< e1,e2 >}
     基本操作：
     InitCom(&C,ee1,ee2)
     操作结果：构造一个二元组c，元素e1,e2分别被赋成ee1,ee2。
     FirElemBig(C)
     初始条件：二元组已经存在。
     操作结果：如果首元素大，则返回1，否则返回0。
     ...
   } ADT Compare

```

**抽象数据类型的表示**  
* 抽象数据类型的表示就是要将该类型映射到计算机中，也就是确定抽象数据类型的存储结构以及给出基于该结构上的基本操作的函数原型。  
```
       typedef  int   ElemType; //整形元组
       typedef  ElemType  * Compare; //动态顺序存储结构
       //初始化二元组
       InitCom(Compare  &C, ElemType  ee1, ElemType  ee2)

       //判断二元组的首元素是否比次元素大
       FirElemBig(Compare  C)
       ……
```
**抽象数据类型的实现**  
* 抽象数据类型的实现就是基于特定存储结构之上的基本操作的实现。  
初始化二元组例子：  
```
       Status InitCom(Compare  &C, ElemType  ee1, ElemType  ee2)
        {
               C = (ElemType *)malloc(2*sizeof(ElemType));
               if(!C) exit (OVERFLOW);
                C[0] = ee1;  C[1] = ee2;
                return OK;
        }

        //判断二元组的首元素是否大
       Status FirElemBig(Compare  C)
       {
                 if(C[0] > C[1])  return  TRUE;
                 else  return  FALSE;
       }

```

### 算法的基本概念  
算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。  
* 算法的五个特性 ：**有穷性 确定性 可行性 0个或多个输入 1个或多个输出**  
* 算法的设计要求 ： **正确性  可读性  健壮性  高效率  低存储**  

算法的含义与程序十分相似，但二者是有区别的。  
1. 一个程序不一定满足有穷性
2. 程序中的指令必须是机器可执行的，而算法中的指令则无此限制。算法若用计算机语言来书写，则它就可以是程序。  
    一个算法可以用自然语言或约定符号来描述，也可以用流程图、计算机高级程序语言（如C语言）或伪代码等来描述。

#### 算法的表现形式  
**冒泡排序**
```
void   bubble_sort(int   a[] , int  n)
{    
//将a中整数序列按从小到大的顺序排序
	  for(i = n-1;i>=1; i--)
	  {
             for(j = 0; j<i;j++)
		       if(a[j] > a[j+1])
		       {
			a[j]<--->a[j+1];
		       } 
}
```

**优化冒泡排序**
```
void   bubble_sort(int   a[] , int  n)
{    //将a中整数序列按从小到大的顺序排序
	  for(i = n-1, change = TURE;i>=1 && change; i--)
	  {
            change = FALSE;//交换标识
             for(j = 0; j<i;j++)
		       if(a[j] > a[j+1])
		       {
			a[j]<--->a[j+1];
                           change = TRUE;
                   } 
}
```
#### 算法效率的度量  
* 事后统计法
* 事前分析法
* 只考虑问题规模（基本操作）  
        一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数f(n),记作：T(n) = O (f(n)),它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。  
* 频度的概念  基本操作的执行次数。  


```
例：{++x; s=0;}
        包含 “x 增 1” 基本操作的语句的频度为１，即时间复杂度 
为O(1)。O(1) 表示算法的运行时间为常量。即：常量阶。


例：for(i =1; i <=n; ++i)
               {++x;  s += x;}
        包含 “x 增 1” 基本操作的语句的频度为：n，其时间复杂度 
为：O(n)，即：线性阶。


例：for(i =1; i <= n;  ++i )
　　　　for(j =1; j <= n; ++j )
                      {++x;  s += x;}
        包含 “x 增 1” 基本操作的语句的频度为：n2，其时间复杂度 
为：O(n2)，即：平方阶。


例：for( i =2; i <= n; ++i )
              for( j =2; j <= i - 1; ++j )
                    {++x;  a[ i, j]=x;}
包含 “x 增 1” 基本操作的语句的频度为：
 1+2+3+…+n-2 = (1+n-2)×(n-2)/2 = (n-1)(n-2)/2  
其时间复杂度为：O(n2)，即：平方阶。 
```

**f(n)的求法**
算法的时间 复杂度常见的有：  
        常数阶 O(1)，对数阶 O(log n)，线性阶 O(n)，线性对数阶 O(nlog n)，平方阶 O(n2)，立方阶 O(n3)，…， k 次方阶O(nk)，指数阶 O(2n)，阶乘阶 O(n!)。


f(n)一般用频度表达式中增长最快的项表示，并将其常数去掉。    
         例如： 假设某元操作的频度：100*2n+8n2  
                          则：T(n)=O(2n)  

  常见的算法的时间 复杂度之间的关系为：  
     O(1)<O(log n)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)  
#### 时间复杂度的三种具体情况  
```
Void bubble-sort(int a[]，int n) 
 {   //将 a 中整数序列重新排列成自小至大有序的整数序列。 
      for(i = n-1, change = TURE; i > 1 && change; --i)
            change = false;
             for ( j = 0;  j < i; ++j)
                 if (a[ j] > a[ j +1]) {a[ j]←→a[ j +1];  change = TURE} 
 }// bubble-sort
```

最好情况： 0 次  

最坏情况： 1 + 2 + …… + n-1 = n(n-1)/2

平均时间复杂度为 ： O(n^2)

**在本课程中讨论的时间复杂度，均指最坏的时间复杂度。**  


#### 算法的存储空间需求
**空间复杂度** ： 算法所需存储空间的度量，记作：S(n) = O (f(n))    （其中 n 为问题的规模）

**一个算法所需存储空间** ：算法本身的存储空间 输入数据的存储空间  算法在运行过程中临时占用的存储空间  

若所需临时空间不随问题规模的大小而改变，则称次算法为 **原地工作**  

## 第二章 线性表

一个线性表是 n 个数据元素的有限序列。

* 线性表：最常用且最简单的一种数据结构。

* 线性结构的特点：4个“唯一”。  
  >       存在唯一的一个被称作 “第一个”的数据元素  
  >       存在唯一的一个被称作“最后一个”的数据元素  
  >       除第一个之外的数据元素均只有一个前驱  
  >       除最后一个之外的数据元素均只有一个后继  
